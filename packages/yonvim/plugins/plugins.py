#!/usr/bin/env nix-shell
#!nix-shell -i python3 -p "python3.withPackages (ps: with ps; [ colorama GitPython humanize requests ])"

import argparse
from colorama import init, Fore, Style
from datetime import datetime
from git import Repo
import humanize
import json
import operator
import os
import requests
import subprocess
import sys


def read_plugins():
    with open("plugins.json", "r") as infile:
        return json.load(infile)


def write_plugins(plugins):
    with open("plugins.json", "w") as outfile:
        json.dump(plugins, outfile, indent=4)


def get_repo_default_branch(owner, repo):
    url = f"https://api.github.com/repos/{owner}/{repo}"
    token = os.environ.get("GITHUB_API_TOKEN", "")
    response = requests.get(
        url,
        headers={
            "Accept": "application/vnd.github+json",
            "Authorization": f"Bearer {token}",
        },
    ).json()
    return response["default_branch"]


def get_git_repo():
    return Repo(os.path.join(os.path.dirname(__file__), "..", "..", ".."))


def get_branch_head_rev(owner, repo, branch):
    url = f"https://api.github.com/repos/{owner}/{repo}/branches/{branch}"
    token = os.environ.get("GITHUB_API_TOKEN", "")
    response = requests.get(
        url,
        headers={
            "Accept": "application/vnd.github+json",
            "Authorization": f"Bearer {token}",
        },
    ).json()
    commit_sha = response["commit"]["sha"]
    date = response["commit"]["commit"]["author"]["date"]
    return {
        "commit_sha": commit_sha,
        "date": datetime.strptime(date, "%Y-%m-%dT%H:%M:%SZ"),
    }


def get_rev_nix_hash(owner, repo, rev_hash):
    url = f"https://github.com/{owner}/{repo}/archive/{rev_hash}.zip"

    try:
        proc = subprocess.run(
            ["nix-prefetch-url", "--type", "sha256", "--unpack", url],
            check=True,
            capture_output=True,
        )
    except subprocess.CalledProcessError as e:
        print(e.stderr.decode())

    sha256 = proc.stdout.decode().splitlines()[0].strip()

    try:
        proc = subprocess.run(
            ["nix", "hash", "to-sri", "--type", "sha256", sha256],
            check=True,
            capture_output=True,
        )
    except subprocess.CalledProcessError as e:
        print(e.stderr.decode())

    return proc.stdout.decode().splitlines()[0].strip()


def sanitize_nix_attr_name(name):
    return name.replace(".", "-")


def generate_nix_derivations(plugins):
    drvs = map(
        lambda p: f"""
  {sanitize_nix_attr_name(p['repo'])} = vimUtils.buildVimPlugin {{
    pname = "{p['repo']}";
    version = "{p['version']}";

    src = fetchFromGitHub {{
      owner = "{p['owner']}";
      repo = "{p['repo']}";
      rev = "{p['rev']}";
      hash = "{p['hash']}";
    }};

    dontBuild = true;

    meta.homepage = "https://github.com/{p['owner']}/{p['repo']}";
  }};
""",
        plugins,
    )

    with open("generated.nix", "w") as outfile:
        outfile.write(
            f"""# This file has been auto-generated by plugins.py. Do not edit!
{{ fetchFromGitHub, vimUtils }}:

_self: {{{"".join(drvs)}}}
"""
        )


def add(location):
    parts = location.split("/")
    if len(parts) != 2:
        print(
            f"Location must be in the format of <owner>/<repo>: {location}",
            file=sys.stderr,
        )
        exit(1)
    owner, repo = parts

    plugins = read_plugins()

    if any(map(lambda p: p["owner"] == owner and p["repo"] == repo, plugins)):
        print(f"Plugin {owner}/{repo} already exists", file=sys.stderr)
        exit(1)

    default_branch = get_repo_default_branch(owner=owner, repo=repo)
    head_rev = get_branch_head_rev(owner=owner, repo=repo, branch=default_branch)
    nix_hash = get_rev_nix_hash(owner=owner, repo=repo, rev_hash=head_rev["commit_sha"])

    plugins.append(
        {
            "version": head_rev["date"].strftime("%Y-%m-%d"),
            "owner": owner,
            "repo": repo,
            "rev": head_rev["commit_sha"],
            "hash": nix_hash,
        }
    )
    plugins.sort(key=lambda p: p["repo"])

    write_plugins(plugins)

    generate_nix_derivations(plugins)


def remove(name):
    plugins = read_plugins()

    try:
        i = next(i for i, p in enumerate(plugins) if p["repo"] == name)
    except StopIteration:
        print(f"Plugin {name} does not exist")
        exit(1)
    plugins.pop(i)

    write_plugins(plugins)

    generate_nix_derivations(plugins)


def update(name):
    git_repo = get_git_repo()

    if git_repo.is_dirty(index=True, working_tree=False, untracked_files=False):
        print(
            "You have uncommitted changes. Please commit or stash your changes first.",
            file=sys.stderr,
        )
        exit(1)

    if git_repo.is_dirty(
        index=True,
        working_tree=True,
        untracked_files=True,
        path="packages/yonvim/plugins/plugins.json",
    ):
        print(
            "packages/yonvim/plugins/plugins.json is dirty. Please commit or stash your changes first.",  # noqa: E501
            file=sys.stderr,
        )
        exit(1)

    plugins = read_plugins()
    plugin = next(p for p in plugins if p["repo"] == name)
    if plugin is None:
        print(f"Plugin {name} is not found", file=sys.stderr)
        exit(1)

    owner, repo, rev, hash = operator.itemgetter("owner", "repo", "rev", "hash")(plugin)

    default_branch = get_repo_default_branch(owner=owner, repo=repo)
    head_rev = get_branch_head_rev(owner=owner, repo=repo, branch=default_branch)
    if head_rev["commit_sha"] != rev:
        print(f"- {owner}/{repo}: {rev} -> {head_rev['commit_sha']}")

        nix_hash = get_rev_nix_hash(
            owner=owner, repo=repo, rev_hash=head_rev["commit_sha"]
        )

        plugin.update(
            {
                "version": head_rev["date"].strftime("%Y-%m-%d"),
                "rev": head_rev["commit_sha"],
                "hash": nix_hash,
            }
        )

        # TODO show the commit log since last update

        write_plugins(plugins)

        generate_nix_derivations(plugins)

        git_repo.index.add(
            [
                "packages/yonvim/plugins/plugins.json",
                "packages/yonvim/plugins/generated.nix",
            ]
        )
        git_repo.index.commit(
            message=f"""feat: bump {repo}

{owner}/{repo}@{rev} -> {owner}/{repo}@{head_rev["commit_sha"]}
"""
        )
    else:
        print(f"- {plugin['owner']}/{plugin['repo']}: up-to-date")


def list_outdated():
    plugins = read_plugins()

    for plugin in plugins:
        owner, repo, commit_sha = operator.itemgetter("owner", "repo", "rev")(plugin)
        url = f"https://api.github.com/repos/{owner}/{repo}/compare/{commit_sha}...HEAD"
        token = os.environ.get("GITHUB_API_TOKEN", "")
        response = requests.get(
            url,
            headers={
                "Accept": "application/vnd.github+json",
                "Authorization": f"Bearer {token}",
            },
        ).json()
        commits = response["commits"]
        if len(commits) == 0:
            continue
        latest_commit_sha = commits[-1]["sha"]

        status = []
        if response["ahead_by"] != 0:
            status.append(f'{response["ahead_by"]} commits ahead')
        if response["behind_by"] != 0:
            status.append(f'{response["behind_by"]} commits behind')
        print(f"{owner}/{repo}", end="")
        print(
            f" {Style.BRIGHT}{commit_sha[0:7]} -> {latest_commit_sha[0:7]}{Style.RESET_ALL}",  # noqa: E501
            end="",
        )
        if len(status) != 0:
            print(f' {Style.DIM}({", ".join(status)}){Style.RESET_ALL}')
        for commit in commits:
            sha, message, date = (
                commit["sha"],
                commit["commit"]["message"],
                commit["commit"]["author"]["date"],
            )
            print("  ", end="")
            print(f"{Fore.RED}{sha[0:7]}{Style.RESET_ALL}", end="")
            print(f" {message.splitlines()[0].strip()}", end="")
            print(
                f' {Style.DIM}({humanize.naturaltime(datetime.strptime(date, "%Y-%m-%dT%H:%M:%SZ"))}){Style.RESET_ALL}'  # noqa: E501
            )
        print("")


def main():
    init(autoreset=True)

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest="subcommand")

    add_parser = subparsers.add_parser("add", help="add plugin")
    add_parser.add_argument(
        "location",
        type=str,
        help="plugin repository to add (formats in <owner>/<repo>)",
    )

    remove_parser = subparsers.add_parser("remove", help="remove plugin")
    remove_parser.add_argument("name", type=str, help="plugin name to remove")

    update_parser = subparsers.add_parser("update", help="update plugin")
    update_parser.add_argument("name", type=str, help="plugin name to update")

    subparsers.add_parser("outdated", help="list outdated plugins")

    args = parser.parse_args()

    if args.subcommand == "add":
        add(args.location)
    elif args.subcommand == "remove":
        remove(args.name)
    elif args.subcommand == "update":
        update(args.name)
    elif args.subcommand == "outdated":
        list_outdated()
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
